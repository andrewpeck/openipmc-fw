
/********************************************************************************/
/*                                                                              */
/*    OpenIPMC-FW                                                               */
/*    Copyright (C) 2020-2021 Andre Cascadan, Luigi Calligaris                  */
/*                                                                              */
/*    This program is free software: you can redistribute it and/or modify      */
/*    it under the terms of the GNU General Public License as published by      */
/*    the Free Software Foundation, either version 3 of the License, or         */
/*    (at your option) any later version.                                       */
/*                                                                              */
/*    This program is distributed in the hope that it will be useful,           */
/*    but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
/*    GNU General Public License for more details.                              */
/*                                                                              */
/*    You should have received a copy of the GNU General Public License         */
/*    along with this program.  If not, see <https://www.gnu.org/licenses/>.    */
/*                                                                              */
/********************************************************************************/

#include <stdint.h>
#include <stddef.h>
#include <stdio.h>

#include <FreeRTOS.h>

#include <stm32h7xx_hal.h>

//OpenIPMC includes
#include "sdr_manager.h"
#include "power_manager.h"
#include "fru_inventory_manager.h"
#include "sdr_definitions.h"
#include "sensors_templates.h"
#include "device_id.h"
#include "fw_identification.h"

// This headers are generated by Eclipse before compiling. See header_gen.sh file.
#include "head_commit_sha1.h"
#include "compiling_epoch.h"
#include "apollo.h"
#include "user_eeprom.h"

extern void board_specific_sensor_inits();

static void power_initialization(void);

/*
 * Sensor reading functions
 *
 * These functions tell OpenIPMC how to get the sensor reading.
 *
 * Defined on openipmc_brd_ctrls.c file
 */
sensor_reading_status_t sensor_reading_fpga_temp(sensor_reading_t* sensor_reading);
sensor_reading_status_t sensor_reading_air_temp(sensor_reading_t* sensor_reading);
sensor_reading_status_t sensor_reading_vcc_out(sensor_reading_t* sensor_reading);


/*
 * This function is called by OpenIPMC during initialization process. The
 * following initializations are expected to be done by this function:
 *   - Initial power scheme
 *   - FRU Inventory
 *   - Sensor Records (if any)
 */
void ipmc_custom_initialization()
{

	/*
	 * Power Initialization.
	 *
	 * To simplify the example, the Power Initialization was wrapped in a function
	 * defined later in this file.
	 */
	power_initialization();

	/*
	 *  Create FRU Inventory
	 */


	uint8_t sn = 0;
  if (0==user_eeprom_read()) {
		user_eeprom_get_serial_number(&sn);
	}

	char sm_sn [9];
	snprintf(sm_sn, 9, "SM%05d", sn);

	char sm_rev [9] = "REV00000";
	uint8_t rev = apollo_get_revision();

	if (rev==APOLLO_REV1)
		snprintf(sm_rev, 9, "REV00001");
	else if (rev==APOLLO_REV2)
		snprintf(sm_rev, 9, "REV00002");
	else if (rev==APOLLO_REV2A)
		snprintf(sm_rev, 9, "REV0002A");

	unsigned int id = HAL_GetUIDw0() + HAL_GetUIDw1() + HAL_GetUIDw2();

	char ipmc_id [9];
	snprintf(ipmc_id, 9, "%08X", id);

	char ipmc_sha [9];
	snprintf(ipmc_sha, 9, "%08X", HEAD_COMMIT_SHA1);

	// Create the Board Info Area
	fru_inventory_field_t board_info;
	board_info = create_board_info_field ( COMPILING_EPOCH/60 - 13674240,  // Manufacturing Date/Time (Here is being inserted the compiling time in GMT)
	                                       "SPRACE-KIT",        // Board Manufacturer       (string fields: max of 63 ASCII char)
	                                       "OpenIPMC-HW",       // Board Product Name
	                                       ipmc_id,             // Board Serial Number == DSN
	                                       ipmc_sha,            // Board Part Number == Git SHA
	                                       "file.xml"    );     // FRU File ID
	// Create the Product Info Area
	fru_inventory_field_t product_info;
	product_info = create_product_info_field ( "BOSTON-UNIVERSITY", // Manufacturer Name       (string fields: max of 63 ASCII char)
	                                           "APOLLO-BLADE",      // Product Name
	                                           sm_rev,              // Product Part/Model == SM Revision
	                                           "1.0",               // Product Version == IPMC Hardware Version
	                                           sm_sn,               // Product Serial Number == SM Serial
	                                           "2021-1234",         // Asset tag == ??
	                                           "file.xml"      );   // FRU File ID


	// Aggregates FRU Info areas to create the FRU Info inventory
	create_fru_inventory ( NULL,             // Internal Use Field NOT USED
	                       NULL,             // Chassis Info Field NOT USED
	                       board_info,
	                       product_info,
	                       NULL,             // Multi Record Field NOT USED
	                       0             );  // Multi Record Field NOT USED

	// The individual areas now can be freed
	vPortFree( board_info   );
	vPortFree( product_info );



	/*
	 * Define the device identification and capabilities (Device ID)
	 * This information refers to the IPMC itself
	 */
	ipmc_device_id.firmware_major_revision       = FW_VERSION_MAJOR;    // Integer 0 ~ 127
	ipmc_device_id.firmware_minor_revision       = FW_VERSION_MINOR;    // BCD from 00 to 99 (two digits) Example: Ver. 1.2.3 -> 0x23
	ipmc_device_id.device_revision               = 1;                   // Integer 0 ~ 15
	ipmc_device_id.manufacturer_id               = MANUFACTURER_ID;
	ipmc_device_id.product_id                    = PRODUCT_ID;
	ipmc_device_id.auxiliar_firmware_rev_info[0] = (HEAD_COMMIT_SHA1>>24)&0xFF;
	ipmc_device_id.auxiliar_firmware_rev_info[1] = (HEAD_COMMIT_SHA1>>16)&0xFF;
	ipmc_device_id.auxiliar_firmware_rev_info[2] = (HEAD_COMMIT_SHA1>>8 )&0xFF;
	ipmc_device_id.auxiliar_firmware_rev_info[3] = (HEAD_COMMIT_SHA1    )&0xFF;
	ipmc_device_id.device_id_string              = "APOLLO-OPENIPMC";    // String, 16 characters maximum.
	ipmc_device_id.device_support                = DEVICE_SUPPORT_IPMB_EVENT_GENERATOR  |
	                                               DEVICE_SUPPORT_FRU_INVENTORY         |
	                                               DEVICE_SUPPORT_SENSOR                ;



	/*
	 *  Create Sensors
	 */

	uint8_t threshold_list[6];

	init_sdr_repository();

	create_hot_swap_carrier_sensor ("Hot Swap Carrier");
	create_ipmb0_sensor ("IPMB-0 Sensor");

	// Dummy sensor for FPGA temperature.
	threshold_list[0] = 0;    // Lower Non Recoverable NOT USED
	threshold_list[1] = 0;    // Lower Critical        NOT USED
	threshold_list[2] = 0;    // Lower Non Critical    NOT USED
	threshold_list[3] = 65;   // Upper Non Critical    65°C
	threshold_list[4] = 75;   // Upper Critical        75°C
	threshold_list[5] = 100;  // Upper Non Recoverable 100°C
	create_generic_analog_sensor_1( TEMPERATURE,
	                                DEGREES_C,
	                                1,            // y = 1*x + 0  (temperature in °C is identical to it raw value)
	                                0,
	                                0,
	                                0,
	                                UPPER_NON_CRITICAL | UPPER_CRITICAL | UPPER_NON_RECOVERABLE,
	                                threshold_list,
	                                "DUMMY TEMP",
	                                &sensor_reading_fpga_temp );


	// Dummy sensor for Air temperature.
	// threshold_list[0] = 0;    // Lower Non Recoverable  NOT USED
	// threshold_list[1] = 0;    // Lower Critical         NOT USED
	// threshold_list[2] = 0;    // Lower Non Critical     NOT USED
	// threshold_list[3] = 100;  // Upper Non Critical     30°C  (see conversion below)
	// threshold_list[4] = 120;  // Upper Critical         40°C
	// threshold_list[5] = 0;    // Upper Non Recoverable  NOT USED
	// create_generic_analog_sensor_1( TEMPERATURE,
	//                                 DEGREES_C,
	//                                 5,            // y = (0.5*x - 20) = (5*x - 200)*0.1
	//                                 -200,
	//                                 0,
	//                                 -1,
	//                                 UPPER_NON_CRITICAL | UPPER_CRITICAL,
	//                                 threshold_list,
	//                                 "AIR TEMP",
	//                                 &sensor_reading_air_temp );


	// Dummy sensor for Voltage.
	// threshold_list[0] = 0;    // Lower Non Recoverable  NOT USED
	// threshold_list[1] = 0;    // Lower Critical         NOT USED
	// threshold_list[2] = 0;    // Lower Non Critical     NOT USED
	// threshold_list[3] = 0;    // Upper Non Critical     NOT USED
	// threshold_list[4] = 0;    // Upper Critical         NOT USED
	// threshold_list[5] = 0;    // Upper Non Recoverable  NOT USED
	// create_generic_analog_sensor_1( VOLTAGE,
	//                                 VOLTS,
	//                                 1,            // y = 0.1*x = (1*x + 0)*0.1
	//                                 0,
	//                                 0,
	//                                 -1,
	//                                 0, // No thresholds
	//                                 threshold_list,
	//                                 "12V_RAIL",
	//                                 &sensor_reading_vcc_out );


	board_specific_sensor_inits();

}



uint8_t get_fru_control_capabilities (void)
{
	uint8_t const capabilities = 0; // WARM_RESET_SUPPORTED | GRACEFUL_REBOOT_SUPPORTED | DIAGNOSTIC_INTERRUPT_SUPPORTED
	return capabilities;
}


static void power_initialization(void)
{

	power_envelope_t pwr_envelope;

	pwr_envelope.num_of_levels =  2; // Max of 20 beyond the 0-th value
	pwr_envelope.multiplier    = 10; // Global multiplier in tenths of Watt

	// REMINDER: PICMG spec **requires** the maximum power envelope values in this array to increase monotonically!
	pwr_envelope.power_draw[ 0] = 0;   // Power Level 0: RESERVED and always means 0 Watt (payload off)
	pwr_envelope.power_draw[ 1] = 20;  // Power Level 1: 20 Watts ( power_draw[1] * multiplier * 0.1W = 20 * 10 * 0.1 W = 20W )
	pwr_envelope.power_draw[ 2] = 100; // Power Level 2: 100 Watts
	//pwr_envelope.power_draw[ 3] = 110;
	//pwr_envelope.power_draw[ 4] = 140;
	//pwr_envelope.power_draw[ 5] = 150;
	//pwr_envelope.power_draw[ 6] = 160;
	//pwr_envelope.power_draw[ 7] = 170;
	//pwr_envelope.power_draw[ 8] = 180;
	//pwr_envelope.power_draw[ 9] = 190;
	//pwr_envelope.power_draw[10] = 210;
	//pwr_envelope.power_draw[11] = 211;
	//pwr_envelope.power_draw[12] = 212;
	//pwr_envelope.power_draw[13] = 213;
	//pwr_envelope.power_draw[14] = 214;
	//pwr_envelope.power_draw[15] = 215;
	//pwr_envelope.power_draw[16] = 216;
	//pwr_envelope.power_draw[17] = 217;
	//pwr_envelope.power_draw[18] = 218;
	//pwr_envelope.power_draw[19] = 219;
	//pwr_envelope.power_draw[20] = 310;

	ipmc_pwr_setup_power_envelope(pwr_envelope);  // Copy the envelope to the power manager

	// Here must be informed the Power Level desired by the payload. It must be a valid index of the power_draw array (1 up to num_of_levels).
	ipmc_pwr_set_desired_power_level(2); // Power Level 2 means 100 Watts, following what is specified in the power_draw array above.
}
